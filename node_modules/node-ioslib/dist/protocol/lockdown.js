"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const plist = require("plist");
const protocol_1 = require("./protocol");
const debug = require('debug')('protocol:lockdown');
exports.LOCKDOWN_HEADER_SIZE = 4;
function isDefined(val) {
    return typeof val !== "undefined";
}
function isLockdownResponse(resp) {
    return isDefined(resp.Status);
}
exports.isLockdownResponse = isLockdownResponse;
function isLockdownErrorResponse(resp) {
    return isDefined(resp.Error);
}
exports.isLockdownErrorResponse = isLockdownErrorResponse;
class LockdownProtocolClient extends protocol_1.ProtocolClient {
    constructor(socket) {
        super(socket, new protocol_1.ProtocolReaderFactory(LockdownProtocolReader), new LockdownProtocolWriter());
    }
}
exports.LockdownProtocolClient = LockdownProtocolClient;
class LockdownProtocolReader extends protocol_1.PlistProtocolReader {
    constructor(callback) {
        super(exports.LOCKDOWN_HEADER_SIZE, callback);
    }
    parseHeader(data) {
        return data.readUInt32BE(0);
    }
    parseBody(data) {
        const resp = super.parseBody(data);
        debug(`Response: ${JSON.stringify(resp)}`);
        if (isLockdownErrorResponse(resp)) {
            throw new Error(resp.Error);
        }
        return resp;
    }
}
exports.LockdownProtocolReader = LockdownProtocolReader;
class LockdownProtocolWriter {
    write(socket, plistData) {
        debug(`socket write: ${JSON.stringify(plistData)}`);
        const plistMessage = plist.build(plistData);
        const header = Buffer.alloc(exports.LOCKDOWN_HEADER_SIZE);
        header.writeUInt32BE(plistMessage.length, 0);
        socket.write(header);
        socket.write(plistMessage);
    }
}
exports.LockdownProtocolWriter = LockdownProtocolWriter;
